<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="俺浅薄的docker+Linux学习，从醉醉最基本的Linux虚拟机安装使用到dockerfile的书写，“保姆”级学习流程，当然里面可能“屁话”过多，hhh。请多多指教！  Linux-Docker Examples2019.11.16 - 1.Virtual Machine下载最新版VirtualBox创建一个1GB内存+动态15GB磁盘，名为CentOS的虚拟机。注意，放在合适的位置htt">
<meta property="og:type" content="article">
<meta property="og:title" content="Doooooooocker!">
<meta property="og:url" content="http://yoursite.com/2020/03/18/Doooooooocker/index.html">
<meta property="og:site_name" content="「Riceのこと」">
<meta property="og:description" content="俺浅薄的docker+Linux学习，从醉醉最基本的Linux虚拟机安装使用到dockerfile的书写，“保姆”级学习流程，当然里面可能“屁话”过多，hhh。请多多指教！  Linux-Docker Examples2019.11.16 - 1.Virtual Machine下载最新版VirtualBox创建一个1GB内存+动态15GB磁盘，名为CentOS的虚拟机。注意，放在合适的位置htt">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.runoob.com/wp-content/uploads/2014/06/003vPl7Rty6E8kZRlAEdc690.jpg">
<meta property="og:image" content="https://docs.docker.com/images/Container%402x.png">
<meta property="og:image" content="https://docs.docker.com/images/VM%402x.png">
<meta property="og:image" content="https://images2015.cnblogs.com/blog/918915/201701/918915-20170126134304191-517283657.png">
<meta property="og:image" content="https://img-blog.csdn.net/20170419135324953">
<meta property="og:image" content="https://img-blog.csdn.net/20170419135439094">
<meta property="article:published_time" content="2020-03-18T10:51:59.000Z">
<meta property="article:modified_time" content="2020-03-18T10:54:52.549Z">
<meta property="article:author" content="Rice March">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.runoob.com/wp-content/uploads/2014/06/003vPl7Rty6E8kZRlAEdc690.jpg">

<link rel="canonical" href="http://yoursite.com/2020/03/18/Doooooooocker/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

  <title>Doooooooocker! | 「Riceのこと」</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">「Riceのこと」</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/18/Doooooooocker/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rice March">
      <meta itemprop="description" content="个人杂物箱、 关于编程、日语、生活和阳光 Long may the sunshine!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="「Riceのこと」">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Doooooooocker!
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-18 18:51:59 / 修改时间：18:54:52" itemprop="dateCreated datePublished" datetime="2020-03-18T18:51:59+08:00">2020-03-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>俺浅薄的docker+Linux学习，从醉醉最基本的Linux虚拟机安装使用到dockerfile的书写，“保姆”级学习流程，当然里面可能“屁话”过多，hhh。请多多指教！</p>
</blockquote>
<h1 id="Linux-Docker-Examples"><a href="#Linux-Docker-Examples" class="headerlink" title="Linux-Docker Examples"></a>Linux-Docker Examples</h1><h3 id="2019-11-16-1-Virtual-Machine"><a href="#2019-11-16-1-Virtual-Machine" class="headerlink" title="2019.11.16 - 1.Virtual Machine"></a>2019.11.16 - 1.Virtual Machine</h3><p>下载最新版VirtualBox<br>创建一个1GB内存+动态15GB磁盘，名为CentOS的虚拟机。注意，放在合适的位置<br><a href="https://opsx.alibaba.com/mirror" target="_blank" rel="noopener">https://opsx.alibaba.com/mirror</a><br>下载CentOS7.7.1908，DVD iso版，4.66GB(4.34GB)<br>在虚拟机的光驱，引入下载的CentOS镜像<br>鉴于需登录的校园网络特点，网络模式使用默认的NAT模式<br>桥接，默认的网络地址转换(NAT)的区别？<br>从虚拟机切出鼠标/键盘的控制的快捷键？</p>
<h3 id="2019-11-16-2-CentOS"><a href="#2019-11-16-2-CentOS" class="headerlink" title="2019.11.16 - 2.CentOS"></a>2019.11.16 - 2.CentOS</h3><p>运行虚拟机，进入centos安装模式<br>打开网络功能，默认的自动分配IP<br>安装位置，无需分区<br>安装minimal版，后续软件包可以再添加<br>安装过程中，设置root账号密码，创建一个普通操作权限的用户/密码<br>安装时，查找资料了解root/普通用户，Linux系统操作权限管理<br>安装完毕，光驱卸载iso，重启</p>
<p>初学者可以直接以root账号登录<br>查看网络是否正常，ping通百度<br>停止操作快捷键？自动补全快捷键？</p>
<h3 id="2019-11-16-3-SSH"><a href="#2019-11-16-3-SSH" class="headerlink" title="2019.11.16 - 3.SSH"></a>2019.11.16 - 3.SSH</h3><p>win10可安装win10自带的OpenSSH客户端。什么是SSH？<br>Win7安装Bitvise SSH Client或其他SSH客户端<br>在VB网络设置中，创建一个宿主机到虚拟机的ssh端口映射<br>通过控制台，以root登入虚拟机，注意需显式声明端口参数<br>为什么通过ssh连接服务器，而不直接在虚拟机中操作？</p>
<p>如果能够正确进入服务器，则可以在VB中为虚拟机创建一个系统快照作为基础镜像，<br>后续操作出问题，可以回滚到当前版本。当然，直接删了虚拟机重来也很方便</p>
<h3 id="2019-11-16-4-Don’t-Be-Scared-of-the-Terminal"><a href="#2019-11-16-4-Don’t-Be-Scared-of-the-Terminal" class="headerlink" title="2019.11.16 - 4.Don’t Be Scared of the Terminal"></a>2019.11.16 - 4.Don’t Be Scared of the Terminal</h3><p>基本命令<br>清屏，快速删除命令，列出，进入/退出目录，根目录，home目录，<br>创建/删除/重命名目录，查看系统版本，系统内核，cpu/内存占用，磁盘占用。要使用自动补全<br>在/home/用户下，练习创建/删除/重命名目录</p>
<h3 id="2019-11-23-5-vi"><a href="#2019-11-23-5-vi" class="headerlink" title="2019.11.23 - 5.vi"></a>2019.11.23 - 5.vi</h3><p>vi，Linux经典编辑器<br>在/home/用户下，基于vi创建文件test，编写C语言主函数打印输出hello world</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ vi test</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Hello world of docker!\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#96;esc&#96; + &#96;:w&#96; +&#96;:q&#96;</span><br></pre></td></tr></table></figure>
<p><code>ctrl+z+z</code> 不保存退出<br><code>shift+z+z</code> 保存退出<br>掌握最基本的操作指令，编辑模式/删除整行/保存退出/不保存退出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">先按Esc键,再按以下</span><br><span class="line">:wq或:x                      保存并退出(会保存修改的文件内容)</span><br><span class="line">:q                           退出，适用于未修改的文件</span><br><span class="line">:q!                          强制退出，适用于修改文件后不保存退出(加感叹号表示强制,不会保存修改的文件内容)</span><br></pre></td></tr></table></figure>
<p>在/home/用户下，创建名为code的目录，将文件重命名为hello.c；移动到code目录。即，学习掌握基本的重命名/移动命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir code &#x2F;&#x2F;创建名为code目录</span><br><span class="line">$ cd .. &#x2F;&#x2F;退回home目录</span><br><span class="line">$ mv test hello.c &#x2F;&#x2F;将文件重命名为hello.c</span><br></pre></td></tr></table></figure>
<p>Linux mv 命令用来为文件或目录改名、或将文件或目录移入其它位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv [options] source dest</span><br><span class="line">mv [options] source... directory</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>命令格式</th>
<th>运行结果</th>
</tr>
</thead>
<tbody><tr>
<td>mv 文件名 文件名</td>
<td>将源文件名改为目标文件名</td>
</tr>
<tr>
<td>mv 文件名 目录名</td>
<td>将文件移动到目标目录</td>
</tr>
<tr>
<td>mv 目录名 目录名</td>
<td>目标目录已存在，将源目录移动到目标目录；目标目录不存在则改名</td>
</tr>
<tr>
<td>mv 目录名 文件名</td>
<td>出错</td>
</tr>
<tr>
<td>### 2019.11.23 - 6.yum</td>
<td></td>
</tr>
<tr>
<td>了解linux的软件管理方式</td>
<td></td>
</tr>
<tr>
<td>yum？repo？rpm？为什么使用yum？基于yum下载的是程序源码还是编译完的二进制文件？</td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<ol start="0">
<li>Yum(全称为 Yellow dogUpdater, Modified)是一个在Fedora和RedHat以及CentOS中的Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。yum提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。</li>
<li>RPM 全称为：Red-Hat Package Manager，即红帽 Linux 发行版的软件包管理器。</li>
<li>linux下，repo文件都是存放在/etc/yum.repos.d文件夹之中的。repo文件即是我们常说的源文件(repositry匹配文件)，在使用yum命令的时候系统会自动读取repo文件，然后去repositry获取软件。</li>
<li>比起使用rpm命令安装软件，yum方式安装会自动下载依赖文件，更加的方便</li>
<li>基于yum下载的是编译完的二进制文件</li>
</ol>
</blockquote>
<p>为什么有时需要下载源码在本地编译，而不是直接下载编译好的二进制文件？</p>
<blockquote>
<p>从源代码制作软件的过程，称之为是软件编译。从源代码构建成软件的编译有两种方式：</p>
<ul>
<li>本机编译 （Natively Compiled），对应编译型语言。(C 语言是本机编译)</li>
<li>解释编译（Interpreted Compiled），对应解释性语言。(如 Python，就需要一个编译步骤，把源代码构建成 Python 的语言解释器（称为 CPython）的可以执行文件)<br>实际上，我们在构建二进制 RPM 包时，有两种构建方法：</li>
<li>从源码构建 SRPM，然后再构建二进制 RPM</li>
<li>直接从源码构建二进制 RPM。<br>然而，在软件开发中，我们通常会采用第一种方法，因为它有<strong>以下优势</strong>：</li>
</ul>
<ol>
<li>便于保留的 RPM 版本的确切来源（以 Name-Version-Release 格式标注）。这对于 debug 非常有用。</li>
<li>需要在不同的处理器硬件平台上使用 SRPM 构建二进制 RPM。</li>
</ol>
</blockquote>
<p>学习yum基本命令：列出所有已安装，基于通配符查询已安装，所有可更新，更新全部可更新，基于通配符列出远程仓库匹配的软件包，安装所需软件包<br>无需添加国内仓库镜像网址，centos自动在延迟最小的仓库下载(我这是上海交大/163镜像)。还是要理解yum repo</p>
<ul>
<li>列出所有已安装的软件包 ：<code>yum list installed</code></li>
<li>基于通配符查询已安装<code>yum list installed ^bash     #这个根据自己会的正则表达式进行筛选</code><br><code>yum list|grep gcc</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">“| ”管道符用法</span><br><span class="line"></span><br><span class="line">上一条命令的输出，作为下一条命令参数</span><br><span class="line"></span><br><span class="line">方式：command1 | command2</span><br></pre></td></tr></table></figure></li>
<li>列出资源库中与正则表达式匹配的所有可以更新的rpm包<code>yum list updates #正则表达式匹配</code></li>
<li>查看信息<code>yum info installed gcc</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 安装</span><br><span class="line">yum install 全部安装</span><br><span class="line">yum install package1 安装指定的安装包package1</span><br><span class="line">yum groupinsall group1 安装程序组group1</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2 更新和升级</span><br><span class="line">yum update 全部更新</span><br><span class="line">yum update package1 更新指定程序包package1</span><br><span class="line">yum check-update 检查可更新的程序</span><br><span class="line">yum upgrade package1 升级指定程序包package1</span><br><span class="line">yum groupupdate group1 升级程序组group1</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3 查找和显示</span><br><span class="line">yum info package1 显示安装包信息package1</span><br><span class="line">yum list 显示所有已经安装和可以安装的程序包</span><br><span class="line">yum list package1 显示指定程序包安装情况package1</span><br><span class="line">yum groupinfo group1 显示程序组group1信息yum search string 根据关键字string查找安装包</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4 删除程序</span><br><span class="line">yum remove &amp;#124; erase package1 删除程序包package1</span><br><span class="line">yum groupremove group1 删除程序组group1</span><br><span class="line">yum deplist package1 查看程序package1依赖情况</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">5 清除缓存</span><br><span class="line">yum clean packages 清除缓存目录下的软件包</span><br><span class="line">yum clean headers 清除缓存目录下的 headers</span><br><span class="line">yum clean oldheaders 清除缓存目录下旧的 headers</span><br><span class="line">yum clean, yum clean all (&#x3D; yum clean packages; yum clean oldheaders) 清除缓存目录下的软件包及旧的header</span><br></pre></td></tr></table></figure>
<p>基于yum安装gcc，查看是否已安装<br><code>yum install gcc</code><br><code>yum info installed gcc</code></p>
<p>基于gcc将code目录下的hello.c，编译生成可运行的名为hello的文件，运行查看输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o hello hello.c</span><br><span class="line">$ .&#x2F;hello</span><br></pre></td></tr></table></figure>
<p>也可安装openjdk11，编写Java版hello world。java11起可直接通过java命令运行，自动先编译<br>gcc安装到哪了？列出安装gcc的位置，各位置的作用，为什么可以在任意位置直接运行gcc命令？<br><code># rpm -ql gcc</code><br><code>whereis gcc</code><br><code>-query 中的 -l  list all license files</code></p>
<blockquote>
<p>简单说PATH就是一组路径的字符串变量，当你输入的命令不带任何路径时，LINUX会在PATH记录的路径中查找该命令。有的话则执行，不存在则提示命令找不到，也就是我们经常看到的-bash:<code>* * * : command not found</code>。比如在根目录/下可以输入命令<code>ls</code>,在/usr目录下也可以输入<code>ls</code>,但其实<code>ls</code>命令根本不在这个两个目录下，当你输入ls命令时LINUX会去/bin,/usr/bin,/sbin等目录寻找该命令。而PATH就是定义/bin:/sbin:/usr/bin等这些路劲的变量，其中冒号为目录间的分割符。使用export $PATH命令可以查看环境变量的内容。</p>
</blockquote>
<p>基于yum history卸载(回滚)gcc及全部依赖<br>yum remove卸载时却只卸载这个文件包本身,如果需要删除安装时附加的依赖包可以使用yum history的相关操作实现回滚</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost bin]# yum history list gcc</span><br><span class="line">已加载插件：fastestmirror</span><br><span class="line">ID     | 命令行                   | 日期和时间       | 操作           | 变更数</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">     2 | install gcc              | 2019-11-24 14:20 | I, U           |   11 EE</span><br><span class="line">[root@localhost bin]# yum histroy undo 2</span><br></pre></td></tr></table></figure>
<p>直接删除非空的test目录。命令参数？<br><code>rm -rf code/</code></p>
<h3 id="2019-11-23-7-Directory-Structure"><a href="#2019-11-23-7-Directory-Structure" class="headerlink" title="2019.11.23 - 7.Directory Structure"></a>2019.11.23 - 7.Directory Structure</h3><p>了解根目录下的，主要目录的功能<br>bin/; dev/; mnt/; etc/; opt/; usr/; lib/; home/; /usr/bin/; /usr/lib/; /usr/libexec/;<br><img src="https://www.runoob.com/wp-content/uploads/2014/06/003vPl7Rty6E8kZRlAEdc690.jpg" alt="linux目录结构"><br><code>bin/</code>:bin是Binary的缩写, 这个目录存放着最经常使用的命令.<br><code>dev/</code>:dev是Device(设备)的缩写, 该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。<br><code>mnt/</code>:系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。<br><code>etc/</code>:这个目录用来存放所有的系统管理所需要的配置文件和子目录。<br><code>opt/</code>: 这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。<br><code>usr/</code>: 这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。<br><code>lib/</code>:这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。<br><code>/usr/bin</code>：系统用户使用的应用程序。<br><code>/usr/lib</code>:存放一些函数库、执行文件及连接文件，特别的是，存放在这里面的文件都是不希望直接被用户或shell脚本所使用的文件，在/usr/lib中有非常多的子目录，每一个软件都有其各自所需的函数库；<br><code>/usr/libexec</code>: 目录下存放一些函数库、执行文件及连接文件</p>
<blockquote>
<p>在 Linux 系统中，有几个目录是比较重要的，平时需要注意不要误删除或者随意更改内部文件。<br>/etc： 上边也提到了，这个是系统中的配置文件，如果你更改了该目录下的某个文件可能会导致系统不能启动。<br>/bin, /sbin, /usr/bin, /usr/sbin: 这是系统预设的执行文件的放置目录，比如 ls 就是在/bin/ls 目录下的。<br>值得提出的是，/bin, /usr/bin 是给系统用户使用的指令（除root外的通用户），而/sbin, /usr/sbin 则是给root使用的指令。<br>/var： 这是一个非常重要的目录，系统上跑了很多程序，那么每个程序都会有相应的日志产生，而这些日志就被记录到这个目录下，具体在/var/log 目录下，另外mail的预设放置也是在这里。</p>
</blockquote>
<h3 id="2019-11-30-8-Mount"><a href="#2019-11-30-8-Mount" class="headerlink" title="2019.11.30 - 8.Mount"></a>2019.11.30 - 8.Mount</h3><p><strong>插入一个fat32/ntfs格式U盘，exfat默认不支持<br>设置虚拟机识别读取。基本命令：列出所有指定格式磁盘；挂载设备，浏览设备内文件；取消挂载</strong></p>
<blockquote>
<p>CentOS默认源里没有NTFS-3G，想要添加ntfs支持，无非是自己下载编译安装或者加源yum安装。重新安装了一个CentOS7，用的是添加aliyun的epel源来yum安装的方式，简单易行。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、加源</span><br><span class="line">wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;epel.repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;epel-7.repo</span><br><span class="line">2、安装</span><br><span class="line"># yum update;yum install ntfs-3g</span><br><span class="line">如果系统提示：没有可用软件包，可以输入</span><br><span class="line"># yum install ntfs*</span><br></pre></td></tr></table></figure>
<p><code>fdisk -l</code>or<code>lsblk</code>(后者可以树状结构显示)</p>
<p><code>mount.ntfs-3g  /dev/sdb4 /mnt/</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># umount -v &#x2F;dev&#x2F;sda1          通过设备名卸载  </span><br><span class="line">&#x2F;dev&#x2F;sda1 umounted  </span><br><span class="line"># umount -v &#x2F;mnt&#x2F;mymount&#x2F;      通过挂载点卸载  </span><br><span class="line">&#x2F;tmp&#x2F;diskboot.img umounted</span><br></pre></td></tr></table></figure>

<h3 id="2019-11-26-9-bash-amp-chmod"><a href="#2019-11-26-9-bash-amp-chmod" class="headerlink" title="2019.11.26 - 9.bash &amp; chmod"></a>2019.11.26 - 9.bash &amp; chmod</h3><p><strong>Shell？bash？cat？了解脚本的：基本结构，支持的语句，执行linux命令，运行即可</strong><br>####1.What is shell？</p>
<blockquote>
<p>Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。<br>Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。</p>
<blockquote>
<p>bash是Unix shell的一种，Bash是许多Linux发行版的默认Shell<br>cat 命令用于连接文件并打印到标准输出设备上。（cat是使用方法不仅局限于查看内容，他也可以做到修改内容但是个人平常并不推荐这么用）</p>
</blockquote>
</blockquote>
<p>####2.基本结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">echo &quot;Hello World !&quot;</span><br></pre></td></tr></table></figure>
<p><kbd>#!</kbd> 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。<br>echo 命令用于向窗口输出文本。<br>####3.支持语句<br><kbd>echo</kbd><br><kbd>printf</kbd><br><kbd>test</kbd><br><kbd>for循环语句<kbd>：</kbd></kbd></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for 变量名 in 列表;do</span><br><span class="line">               循环体</span><br><span class="line">       done</span><br></pre></td></tr></table></figure>
<p><strong>shell参数传递：</strong><br><kbd>$#</kbd> :传递到脚本的参数个数<br><kbd>$*</kbd> :以一个单字符串显示所有向脚本传递的参数。如<kbd>"$*"</kbd>用\「&quot;\」括起来的情况、以”$1 $2 … $n”的形式输出所有参数。<br><kbd>$$</kbd>    :脚本运行的当前进程ID号<br><kbd>$!</kbd>    :后台运行的最后一个进程的ID号<br><kbd>$@</kbd>    :与<kbd>$*</kbd>相同，但是使用时加引号，并在引号中返回每个参数。如<kbd>&quot;$@&quot;</kbd>用「”」括起来的情况、以”$1” “$2” … “$n” 的形式输出所有参数。<br><kbd>$-</kbd>    :显示Shell使用的当前选项，与set命令功能相同。<br><kbd>$?</kbd>    :显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</p>
<p><strong>在/home/用户名/test下，基于vi编写一个由bash执行的，打印出/home/用户名/test/下所有文件的脚本<br>需要添加脚本文件的执行权限，运行<br>基于cat读取显式脚本代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">for file in &#96;ls&#96;;do</span><br><span class="line">        echo $file;</span><br><span class="line">done;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">ls &#x2F;home&#x2F;C_program</span><br></pre></td></tr></table></figure>

<p>使用 <kbd>Ctrl</kbd>+<kbd>Z</kbd>+<kbd>Z</kbd>可以直接保存退出</p>
<p><strong>带权限的列出文件</strong><br><code>ls -al</code> <code>ls -l</code>=<code>ll</code><br><strong>chmod命令，r/w/x？3组权限？u/g/o？增加/修改/删除指定角色的指定权限。使用语义参数比数字好记<br>为以上脚本文件，添加创建者具有读写执行权限命令？取消其他用户的读权限？<br>权限角色，u，所有者；g，组；o，其他人</strong></p>
<ul>
<li>u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。  </li>
<li>+ 表示增加权限、- 表示取消权限、= 表示唯一设定权限。  </li>
<li>r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。  </li>
</ul>
<p>r=4,w=2,x=1</p>
<ul>
<li>-c : 若该文件权限确实已经更改，才显示其更改动作</li>
<li>-f : 若该文件权限无法被更改也不要显示错误讯息</li>
<li>-v : 显示权限变更的详细资料</li>
<li>-R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chmod ugo+r file1.txt 所有人皆可读取</span><br><span class="line">chmod a+r file1.txt 所有人皆可读取</span><br><span class="line">chmod ug+w,o-w file1.txt file2.txt 将文件 file1.txt 与 file2.txt 设为该文件拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入</span><br><span class="line">chmod -R a+r * 将目前目录下的所有文件与子目录皆设为任何人可读取</span><br></pre></td></tr></table></figure>
<h3 id="2019-11-26-10-Docker"><a href="#2019-11-26-10-Docker" class="headerlink" title="2019.11.26 - 10.Docker"></a>2019.11.26 - 10.Docker</h3>可以把安装的gcc/openjdk等等都卸载了<br><a href="https://docs.docker.com/engine/docker-overview/" target="_blank" rel="noopener">https://docs.docker.com/engine/docker-overview/</a><br><a href="https://geekflare.com/docker-vs-virtual-machine/" target="_blank" rel="noopener">https://geekflare.com/docker-vs-virtual-machine/</a><br><a href="https://yeasy.gitbooks.io/docker_practice/" target="_blank" rel="noopener">https://yeasy.gitbooks.io/docker_practice/</a><h4 id="1-虚拟化技术-amp-docker虚拟化优势"><a href="#1-虚拟化技术-amp-docker虚拟化优势" class="headerlink" title="1.虚拟化技术&amp;docker虚拟化优势"></a>1.虚拟化技术&amp;docker虚拟化优势</h4></li>
</ul>
<p><strong>了解早先服务器基于虚拟化技术的部署，为什么使用虚拟化技术？当前Docker的虚拟化与之前的区别？优点？了解docker images docker containers？</strong></p>
<p>最大利用化:<br>虚拟化技术可以扩大硬件的容量，简化软件的重新配置过程。CPU的虚拟化技术可以单CPU模拟多CPU并行，允许一个平台同时运行多个操作系统，并且应用程序都可以在相互独立的空间内运行而互不影响，从而显著提高计算机的工作效率。<br>docker 和 之前的区别：</p>
<table>
<thead>
<tr>
<th>Virtual Machine</th>
<th>Docker Container</th>
</tr>
</thead>
<tbody><tr>
<td>Hardware-level process isolation</td>
<td>OS level process isolation</td>
</tr>
<tr>
<td>Each VM has a separate OS</td>
<td>Each container can share OS</td>
</tr>
<tr>
<td>Boots in minutes</td>
<td>Boots in seconds</td>
</tr>
<tr>
<td>VMs are of few GBs</td>
<td>Containers are lightweight (KBs/MBs)</td>
</tr>
<tr>
<td>Ready-made VMs are difficult to find</td>
<td>Pre-built docker containers are easily available</td>
</tr>
<tr>
<td>VMs can move to new host easily</td>
<td>Containers are destroyed and re-created rather than moving</td>
</tr>
<tr>
<td>Creating VM takes a relatively longer time</td>
<td>Containers can be created in seconds</td>
</tr>
<tr>
<td>More resource usage</td>
<td>Less resource usage</td>
</tr>
</tbody></table>
<img src="https://docs.docker.com/images/Container%402x.png" width="300" alt="图片名称">
<img src="https://docs.docker.com/images/VM%402x.png" width="300" alt="图片名称">

<p>Docker engine提供了启动Images和containers核心的技术的支持。当你运行docker run hello-world 命令时，实际上可分为三个部分：<br><img src="https://images2015.cnblogs.com/blog/918915/201701/918915-20170126134304191-517283657.png" alt="运行docker run hello-world的时间过程"></p>
<ol>
<li>告诉你操作系统你正在使用的docker程序</li>
<li>一个子命令创建并且运行docker容器</li>
<li>告诉docker将载入到容器中的Image映像  </li>
</ol>
<p>一个映像是一个文件系统，是在运行时使用的参数，它没有状态和不会改变。容器用来运行映像的实例。当你运行下面命令的时候将会发生下面这些情况：</p>
<ol>
<li>检查你是否有hello-world软件映像</li>
<li>从Docker Hub中下载映像</li>
<li>将映像载入容器中并运行它。</li>
</ol>
<p>依赖于这个映像如何创建，一个映像可能运行一个简单、单一的命令然后退出，hello-world映像就是这样的，不过docker还能启动向数据库那样的软件。Docker引擎能够是人们或者公司创建和分享自己的Docker 映像。使用Docker引擎，你不需要担心你的计算机能否运行Docker映像中的软件，Docker容器总是可以运行它。</p>
<h4 id="2-What-is-vps-and-Cloud-Servers"><a href="#2-What-is-vps-and-Cloud-Servers" class="headerlink" title="2.What is vps and Cloud Servers?"></a>2.What is vps and Cloud Servers?</h4><p><strong>Servers？VPS？Cloud Servers？为什么VPS创建了就开始计时付费？而云可以按流量/CPU内存等的实际使用量弹性付费？</strong></p>
<ul>
<li>vps： 是采用操作系统虚拟化技术，将一台服务器分割为多个虚拟专享服务器<br> 用户和服务器存在一种绑定的关系</li>
<li>云服务器：在服务器集群中采用硬件虚拟化技术。<br> 随时虚拟化的过程</li>
</ul>
<p><a href="https://docs.docker.com/" target="_blank" rel="noopener">https://docs.docker.com/</a><br>官网查找适合centos系统的docker-ce社区稳定版的安装方法。Community版？<br>安装基本工具；添加docker官方仓库，下载docker-ce本身的仓库使用官方地址即可，速度很快。无需指定版本，安装最新版docker-ce<br>启动docker。开机自动启动docker服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost home]# systemctl start docker</span><br><span class="line">[root@localhost home]# docker run hello-world</span><br><span class="line">Unable to find image &#39;hello-world:latest&#39; locally</span><br><span class="line">latest: Pulling from library&#x2F;hello-world</span><br><span class="line">1b930d010525: Pull complete</span><br><span class="line">Digest: sha256:4df8ca8a7e309c256d60d7971ea14c27672fc0d10c5f303856d7bc48f8cc17ff</span><br><span class="line">Status: Downloaded newer image for hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image which runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, which sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"> $ docker run -it ubuntu bash</span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https:&#x2F;&#x2F;hub.docker.com&#x2F;</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https:&#x2F;&#x2F;docs.docker.com&#x2F;get-started&#x2F;</span><br><span class="line"></span><br><span class="line">[root@localhost home]#</span><br></pre></td></tr></table></figure>
<h3 id="2019-11-26-11-Docker-Images"><a href="#2019-11-26-11-Docker-Images" class="headerlink" title="2019.11.26 - 11.Docker Images"></a>2019.11.26 - 11.Docker Images</h3><ul>
<li><strong>docker官方镜像仓库国内速度慢，基于vi修改配置文件，</strong>  </li>
</ul>
<p><code>[root@localhost docker]# vi  /etc/docker/daemon.json</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;dockerhub.azk8s.cn&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用微软Azure仓库<a href="https://dockerhub.azk8s.cn，我这拉取500MB镜像1分钟。基本满速。服务器在国外的不要配。其他仓库要么需要密钥，要么已作废" target="_blank" rel="noopener">https://dockerhub.azk8s.cn，我这拉取500MB镜像1分钟。基本满速。服务器在国外的不要配。其他仓库要么需要密钥，要么已作废</a></p>
<ul>
<li><p><strong>重新加载配置，重启docker</strong><br><code># systemctl status docker.restart</code></p>
<br></li>
<li><p><strong>Docker基本命令：拉取镜像；列出本地镜像；删除镜像；</strong><br>不建议在本地查询，去官方网站查询更方便<br><code># docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</code> 拉取镜像<br><code># docker images</code>:列出本地镜像<br><code># docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</code>:删除本地镜像╰(*°▽°*)╯<br><code>#docker ps -a</code>:查看所有容器记录（包括未运行的容器）</p>
<br></li>
<li><p><strong>不用拉取hello-world测试，直接拉取最新的openjdk</strong><br>如果出现Error response from daemon，说明centos DNS域名解析错误，修改系统DNS解析地址为Google的域名服务器<br><code># docker pull openjdk</code></p>
</li>
<li><p><strong>Docker仓库？docker镜像仓库？</strong><br>仓库（Repository）是集中存放镜像的地方，分为公共仓库和私有仓库。</p>
</li>
</ul>
<h3 id="2019-11-26-12-Docker-Container"><a href="#2019-11-26-12-Docker-Container" class="headerlink" title="2019.11.26 - 12.Docker Container"></a>2019.11.26 - 12.Docker Container</h3><h4 id="Docker-run"><a href="#Docker-run" class="headerlink" title="Docker run"></a>Docker run</h4><p>Docker命令：基于指定镜像创建容器；列出全部已创建的容器；停止运行容器；删除容器。容器ID使用hash值的前2位即可<br>run基本参数：-p；-v；-d；-i；-t；–rm<br><kbd>-p：指定要映射的IP和端口，但是在一个指定端口上只可以绑定一个容器</kbd></p>
<blockquote>
<p>支持的格式有 <code>hostPort:containerPort</code>、<code>ip:hostPort:containerPort</code>、 <code>ip::containerPort</code>。</p>
<blockquote>
<ul>
<li><strong>hostPort:containerPort（映射所有接口地址）</strong><br>将本地的 5000 端口映射到容器的 5000 端口，可以执行如下命令：<br><code>$ sudo docker run -d -p 5000:5000 training/webapp python app.py</code><br>此时默认会绑定本地所有接口上的所有地址。</li>
<li><strong>ip:hostPort:containerPort （映射指定地址的指定端口）</strong><br>指定映射使用一个特定地址，比如 localhost 地址 127.0.0.1<br><code>$ sudo docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py</code></li>
<li><strong>ip::containerPort （映射指定地址的任意端口）</strong><br>绑定 localhost 的任意端口到容器的 5000 端口，本地主机会自动分配一个端口。<br><code>sudo docker run -d -p 127.0.0.1::5000 training/webapp python app.py</code><br>还可以使用 udp 标记来指定 udp 端口<br><code>$ sudo docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py</code></li>
</ul>
</blockquote>
</blockquote>
<p><kbd>-P：Docker 会随机映射一个 49000~49900 的端口到内部容器开放的网络端口<br><kbd>-v：挂载宿主机的一个目录<br><kbd>-d：让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下</kbd></kbd></kbd></p>
<blockquote>
<p>使用 -d 参数启动后会返回一个唯一的 id，也可以通过 <code>docker container ls</code> 命令来查看容器信息。<br>要获取容器的输出信息，可以通过<code>docker container logs</code> 命令</p>
</blockquote>
<p><kbd>-i</kbd>:交互式操作，让容器的标准输入保持打开<br><kbd>-t：让Docker分配一个伪终端并绑定到容器的标准输入上<br><kbd>--rm：    退出时自动删除容器</kbd></kbd></p>
<p>创建容器时，追加在容器启动后，容器内执行操作指令<br>在/home/用户名/test下，创建HelloWorld.java<br><code># vi HelloWorld.java</code></p>
<p>基于openjdk创建一个容器：挂载home/用户名/test/目录到容器内的/home/code/目录，<br>即可以在容器中访问挂载目录中的文件；测试用，创建运行完就删除容器；<br>在前台运行，即显示容器中的输出，后台运行看不到输出；添加容器内java直接运行挂载目录下的HelloWorld的命令</p>
<p><code># docker run -it -v /home/Rice/test/:/home/code/ --rm openjdk  sh -c &quot;cd /home/code &amp;&amp;java HelloWorld.java&quot;</code></p>
<p><code>#docker run -v  /home/Rice/test/:/home/code/ --rm openjdk java home/code/HelloWorld.java</code><br>当容器中没有运行的进程时，容器将关闭。tomcat/MySQL/Nginx等带服务进程的容器会一直运行，<br>而普通openjdk的容器运行即关闭，除非运行像带web容器的springboot<br>如何创建一个不关闭的openjdk容器？<br>创建一个openjdk容器：依然挂载以上目录；启动标准输入，<br>启动终端控制台；在后台运行；在容器内运行/bin/bash。即，创建一个一直运行的进程，使容器不会关闭；<br><code># docker run -it -v /home/Rice/test:/home/code --rm openjdk /bin/bash</code><br>查看容器是否为运行状态<br><code>#docker ps -a</code></p>
<h4 id="Docker-exec"><a href="#Docker-exec" class="headerlink" title="Docker exec"></a>Docker exec</h4><p>exec基本参数：-i；-t。结合/bin/bash使用<br>以可互交的带终端的模式，进入之上创建的后台运行的，未停止的openjdk容器<br>在容器内进入挂载目录，运行HelloWorld，查看输出<br>查看容器内系统版本？查看镜像/容器信息？查看镜像/容器占用？<br>先启动<br><code>docker run -it -d -v /home/Rice/test:/home/code openjdk sh -c &quot;/bin/bash&quot;</code><br>进入容器（exec 不会停止 attach 会停止）<br><code>docker exec -it b4e /bin/bash</code></p>
<p><code>cat /etc/issue</code><br><code>docker inspect  [id/name]</code> 容器id/镜像id查看容器镜像的详细信息。<br><code>docker images [id/name]</code>：查看镜像信息<br><code>ps -ef | grep 8dac6ac683f5</code>:查看镜像/容器占用  </p>
<h3 id="2019-11-26-13-FirewallD-amp-Services"><a href="#2019-11-26-13-FirewallD-amp-Services" class="headerlink" title="2019.11.26 - 13.FirewallD &amp; Services"></a>2019.11.26 - 13.FirewallD &amp; Services</h3><p><strong>CentOS集成的firewall工具。</strong><br>FirewallD 提供了支持网络/防火墙区域(zone)定义网络链接以及接口安全等级的动态防火墙管理工具。<br><strong>ports？firewall zone？使用默认的zone-public无需声明</strong><br>端口可以映射到另一个端口以及/或者其他主机。<br>firewall zone：<br>从不信任到信任的顺序排序</p>
<ul>
<li><code>drop</code>：丢弃，丢弃所有进入的包，而不给出任何响应</li>
<li><code>block</code>：阻塞，拒绝所有外部发起的连接，允许内部发起的连接</li>
<li><code>public</code>：公开，允许指定的进入连接</li>
<li><code>external</code>：外部，同上，对伪装的进入连接，一般用于路由转发</li>
<li><code>dmz</code>：隔离区，允许受限制的进入连接</li>
<li><code>work</code>:工作，允许受信任的计算机被限制的进入连接，类似 workgroup</li>
<li><code>home</code>：家庭，上，类似 homegroup</li>
<li><code>internal</code>：内部，同上，范围针对所有互联网用户</li>
<li><code>trusted</code>：受信任的，信任所有连接</li>
</ul>
<p>列出firewall所有打开服务与端口等信息，这一个命令就够所有查询了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看所有信息</span><br><span class="line"># firewall-cmd --list-all</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查询所有开放的端口。本次运行</span><br><span class="line"># firewall-cmd --list-ports</span><br></pre></td></tr></table></figure>
<p><strong>防火墙重载；永久开启http服务；永久打开80端口；永久关闭服务；永久关闭端口。firewall规则为动态添加，改变规则后需重载，无需重启</strong></p>
<ul>
<li><p>防火墙重载：<br><code>firewall-cmd --reload</code></p>
</li>
<li><p>firewall http 永久服务开启：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --query-service http               ##查看http服务是否支持，返回yes或者no</span><br><span class="line">firewall-cmd --add-service=http                 ##临时开放http服务</span><br><span class="line">firewall-cmd --add-service=http --permanent     ##永久开放http服务</span><br><span class="line">firewall-cmd --reload                           ##重载防火墙生效</span><br></pre></td></tr></table></figure></li>
<li><p>开放某个端口</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 开放某个端口，立即生效。本次运行</span></span><br><span class="line">firewall-cmd --add-port=80/tcp</span><br></pre></td></tr></table></figure></li>
<li><p>永久开放某个端口</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 开放某个端口，重新加载配置后生效。持久</span></span><br><span class="line">firewall-cmd --add-port=80/tcp --permanent</span><br></pre></td></tr></table></figure>
<p><code>-zone #作用域</code><br><code>-add-port=80/tcp #添加端口，格式为：端口/通讯协议</code><br><code>–permanent #永久生效，没有此参数重启后失效</code><br><code>systemctl restart firewalld.service</code></p>
</li>
</ul>
<ul>
<li>永久关闭某个端口、服务<br>将上述开启过程中的<code>--add</code>改为 <code>--remove</code></li>
</ul>
<p><strong>查看一个服务的状态。一个服务的启动/停止/启动/禁用。基于firewalld操作</strong><br>查看状态：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --service=&lt;service&gt; --state</span><br></pre></td></tr></table></figure>
<p>启用服务：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd [--zone=&lt;zone&gt;] --add-service=&lt;service&gt; [--timeout=&lt;seconds&gt;]</span><br></pre></td></tr></table></figure>

<p>#停止：<br>禁止：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd [--zone=&lt;zone&gt;] --remove-service=&lt;service&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2019-11-26-14-Docker-Web-Container"><a href="#2019-11-26-14-Docker-Web-Container" class="headerlink" title="2019.11.26 - 14.Docker Web Container"></a>2019.11.26 - 14.Docker Web Container</h3><p><strong>在宿主机，通过scp命令将本地文件上传到服务器。注意，虚拟机网络为NAT模式，需显式声明ssh映射的端口，但参数与ssh命令不同</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp local_file remote_username@remote_ip:remote_folder</span><br></pre></td></tr></table></figure>
<p><KBD>-r</KBD>：拷贝文件夹</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F:\&gt;scp ./miniprogram.txt root@192.168.56.1:/home/Rice</span><br></pre></td></tr></table></figure>
<p><strong>创建目录，/home/用户名/services/。services下按应用创建目录<br>将/github/resources/docker-examples.war文件下载到本地，再上传到/home/用户名/services/docker-tomcat/。目录需先创建</strong></p>
<p><strong>拉取最新tomcat镜像。</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull tomcat</span><br></pre></td></tr></table></figure>
<p>默认暴露的端口？部署路径？集成的openjdk版本？查看镜像信息？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;ExposedPorts&quot;: &#123;</span><br><span class="line">                &quot;8080&#x2F;tcp&quot;: &#123;&#125;</span><br><span class="line">            &#125;,</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><figcaption><span>"/usr/local/tomcat",```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#96;集成了openjdk1.8&#96;</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;shell</span><br><span class="line">docker inspect tomcat</span><br></pre></td></tr></table></figure>
<p><strong>基于命令行创建一个容器：映射服务器80端口到容器的8080端口；挂载docker-examples.war所在目录到容器中的部署目录；后台运行</strong><br>创建容器 映射服务器80端口到容器8080端口<br>cp method:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 80:8080 tomcat</span><br><span class="line">docker cp /home/Rice/services/docker-tomcat/docker-examples.war bc9:/usr/local/tomcat/webapps</span><br></pre></td></tr></table></figure>
<p><strong>mount method:</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -d -v /home/Rice/services/docker-tomcat/:/usr/local/tomcat/webapps -p 80:8080 tomcat</span><br></pre></td></tr></table></figure>
<p><kbd>  注意是！挂载目录！<kbd> </kbd></kbd></p>
<p>查看容器是否创建/启动成功。容器中的tomcat自动在挂载目录解压war包部署<br>在虚拟机添加端口，例如8888，映射虚拟机的80端口<br>在宿主浏览器，本地+端口+部署在tomcat应用的名称，访问应用</p>
<p><a href="https://github.com/firewalld/firewalld/issues/461" target="_blank" rel="noopener">https://github.com/firewalld/firewalld/issues/461</a><br>创建容器时在服务器映射的端口，即使服务器firewall没有开启服务或端口，外部依然可以直接访问？</p>
<blockquote>
<p>在Linux上，Docker操纵<code>iptables</code>规则以提供网络隔离。这是一个实现细节，您不应修改Docker插入<code>iptables</code>策略中的规则。</p>
</blockquote>
<p>停止，并删除此容器。命令写在一行执行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm $(docker stop CONTAINER ID)</span><br></pre></td></tr></table></figure>
<p>注意，服务器的一个端口只能被一个应用/容器监听，反复创建容器会端口冲突</p>
<h3 id="2019-11-26-15-Dockerfile"><a href="#2019-11-26-15-Dockerfile" class="headerlink" title="2019.11.26 - 15.Dockerfile"></a>2019.11.26 - 15.Dockerfile</h3><p><a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/" target="_blank" rel="noopener">https://docs.docker.com/develop/develop-images/dockerfile_best-practices/</a><br><a href="https://yeasy.gitbooks.io/docker_practice/image/dockerfile/" target="_blank" rel="noopener">https://yeasy.gitbooks.io/docker_practice/image/dockerfile/</a><br><strong>理解docker image layers的设计。优点？</strong></p>
<ul>
<li><p>共享使镜像更小</p>
</li>
<li><p>复制使得容器更高效</p>
</li>
</ul>
<h4 id="1-layer的理解"><a href="#1-layer的理解" class="headerlink" title="1. layer的理解"></a>1. layer的理解</h4><p>  镜像(image)和容器(container)都是基于层(layer)的</p>
<p>  <code>Docker</code>的镜像是由一系列只读层组成的一个栈，上面的层依赖其下面的层，这些层从外面看起来是一个整体。栈底的镜像被称作基础镜像(base image)，所有上面的层都基于这个基础镜像。</p>
<p>  当你在一个容器中进行了某些操作比如添加了一个文件，然后调用<code>docker commit</code>操作创建新的镜像时，<code>Docker</code>会在镜像栈的最上面创建一个新的层，这个层包含了新添加的文件。<br>  或者，通过<code>Dockerfile</code>创建新的镜像时，通过FROM指令指定的就是基础镜像。此后的每条指令都会创建一个新的层，层中包含了这条指令对镜像的修改。</p>
<p>  容器<code>container</code>不仅包含镜像的所有层，它还在最上面添加了一个可读层称作容器层<code>container layer</code>。下面是一个基于<code>ubuntu:15.04</code>运行起来的容器的层之间的关系：</p>
<p>  <img src="https://img-blog.csdn.net/20170419135324953" alt="img"></p>
<p>  容器与镜像的主要区别就在于这个可写层(writable layer),对容器的所有写操作无论是添加新内容还是修改原来的内容都会保存在这个可读层中。如果容器被删除，writable layer也会被删除，但镜像层不变。<br>  正是因为每个镜像都有自己的可写层，所以容器之间可以共享同一个镜像的各层。下面是多个容器使用同一个镜像的例子：</p>
<p>  <img src="https://img-blog.csdn.net/20170419135439094" alt="img"></p>
<p><strong>按官方文档，掌握最基本的FROM RUN CMD COPY ADD指令。每执行一条指令意味着什么？COPY与ADD的区别？</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:18.04</span><br><span class="line">COPY . &#x2F;app</span><br><span class="line">RUN make &#x2F;app</span><br><span class="line">CMD python &#x2F;app&#x2F;app.py</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>FROM</code>从<code>ubuntu:18.04</code>Docker映像创建一个图层。</p>
</li>
<li><p><code>COPY</code> 从Docker客户端的当前目录添加文件。</p>
</li>
<li><p><code>RUN</code>使用构建您的应用程序make。</p>
</li>
<li><p><code>CMD</code> 指定在容器中运行什么命令。</p>
</li>
<li><p><code>ADD</code> 更偏向于文件的解压</p>
</li>
</ul>
<p><strong>在/home/用户名/services/dockers-tomcat/下，编写一个Dockerfile，<br>基于tomcat镜像，将docker-examples.war文件复制到部署路径下。注意，copy指令，只能指定相对于dockerfile的相对路径，不能使用基于根的绝对路径<br>是否需要声明暴露端口？理解layer</strong><br>Dockerfile</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM tomcat</span><br><span class="line">COPY  ./docker-examples.war /usr/local/tomcat/webapps/</span><br></pre></td></tr></table></figure>

<p><code>docker bulid .</code><br>点很重要</p>
<ul>
<li><p>不需要声明暴露端口<br>要将<code>EXPOSE</code>和在运行时使用<code>-p &lt;宿主端口&gt;:&lt;容器端口&gt;</code>区分开来。<code>-p</code>，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而<code>EXPOSE</code>仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。</p>
</li>
<li><p><em>layer的概念：</em><br>Docker 镜像是由多个文件系统（只读层）叠加而成，每个层仅包含了前一层的差异部分。当我们启动一个容器的时候，Docker 会加载镜像层并在其上添加一个可写层。容器上所做的任何更改，譬如新建文件、更改文件、删除文件，都将记录与可写层上。容器层与镜像层的结构如下图所示。</p>
</li>
</ul>
<p><strong>基于文件构建镜像，声明repository仓库名称，注意结尾标识符。repository的官方命名标准？<br>查看镜像是否构建。查看镜像信息?</strong></p>
<p>这里的<code>Repository</code>是指镜像全名在冒号:之前的部分，<br>冒号:之后的部分是镜像的标签（tag），用来区分镜像的版本。 如名为<code>my-app:3.1.4</code>的镜像，<code>my-app</code>就是镜像的 Repository 部分。<br>Repository又可以用斜杠<code>/</code>分隔开，<code>/</code>之前的部分是可选的DNS格式的主机名。主机名必须符合DNS规则，但 <strong>不得</strong> 包含下划线<code>_</code>字符，主机名可以有如<code>：8080</code>格式的端口号。<br>镜像名可以包含小写字符，数字和分隔符。 分隔符是句点.，一个或两个下划线_，或一个或多个短横线-，镜像名<strong>不允许</strong>以分隔符开头或结尾。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker pull 注册服务器的仓库名&#x2F;镜像名:Tag</span><br><span class="line">## 例如：</span><br><span class="line"># docker pull registry.hub.docker.com&#x2F;ubuntu:latest</span><br><span class="line"># docker pull dl.dockerpool.com:5000&#x2F;ubuntu</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当不使用Tag的时候，默认会使用latest进行标记。</p>
</blockquote>
<p><strong>基于自定义构建的镜像创建容器。与之前的创建命令相比，需要什么参数？</strong><br>需要指定dockerfile的位置<br>./URL/-f</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">Dockerfile一般位于构建上下文的根目录下，也可以通过-f指定该文件的位置：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker build -f /path/to/a/Dockerfile .</span></span><br><span class="line"><span class="meta">#</span><span class="bash">构建时，还可以通过-t参数指定构建成后，镜像的仓库、标签等：</span></span><br><span class="line">docker build -f  Dockerfile.test -t image-train-test .</span><br></pre></td></tr></table></figure>

<p>先学习基本镜像构建。其他指令，构建过程优化，后期讨论。不讨论基于容器的镜像构建  </p>
<h3 id="2019-11-26-16-Docker-compose"><a href="#2019-11-26-16-Docker-compose" class="headerlink" title="2019.11.26 - 16.Docker compose"></a>2019.11.26 - 16.Docker compose</h3><h4 id="1-Orchestration-System？"><a href="#1-Orchestration-System？" class="headerlink" title="1. Orchestration System？"></a>1. Orchestration System？</h4><p> 编排是指一次性自动执行多项任务编排系统，简化并优化重复性的频发流程，以确保准确、快速的软件部署</p>
<h4 id="2-为什么需要Docker-Compose？优点？"><a href="#2-为什么需要Docker-Compose？优点？" class="headerlink" title="2. 为什么需要Docker Compose？优点？"></a>2. 为什么需要Docker Compose？优点？</h4><p><code>Docker Compose</code> 是 Docker 官方编排（Orchestration）项目之一，负责快速的部署分布式应用。<code>Compose</code> 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。</p>
<p><code>Compose</code> 恰好满足了这样的需求。它允许用户通过一个单独的 <code>docker-compose.yml</code> 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。</p>
<h4 id="3-k8s-Kubernetes-？k8s与官方docker-compose的适用场景？"><a href="#3-k8s-Kubernetes-？k8s与官方docker-compose的适用场景？" class="headerlink" title="3. k8s(Kubernetes)？k8s与官方docker compose的适用场景？"></a>3. k8s(Kubernetes)？k8s与官方docker compose的适用场景？</h4><p>K8S，就是基于容器的集群管理平台。</p>
<p>Docker Compose是单机管理Docker的，Kubernetes是多节点管理Docker的</p>
<h4 id="4-编写docker-compose文件的最大最大特点？"><a href="#4-编写docker-compose文件的最大最大特点？" class="headerlink" title="4. 编写docker-compose文件的最大最大特点？"></a>4. 编写docker-compose文件的最大最大特点？</h4><p>批量操作！</p>
<p><a href="https://docs.docker.com/compose/" target="_blank" rel="noopener">https://docs.docker.com/compose/</a>  </p>
<h4 id="5-按官网教程安装最新版，添加执行权限"><a href="#5-按官网教程安装最新版，添加执行权限" class="headerlink" title="5. 按官网教程安装最新版，添加执行权限"></a>5. 按官网教程安装最新版，添加执行权限</h4><blockquote>
<p>对于<code>alpine</code>，需要以下依赖包： <code>py-pip</code>，<code>python-dev</code>，<code>libffi-dev</code>，<code>openssl-dev</code>，<code>gcc</code>，<code>libc-dev</code>，和<code>make</code>。</p>
</blockquote>
<ol>
<li><p>运行以下命令以下载Docker Compose的当前稳定版本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -L "https://github.com/docker/compose/releases/download/1.25.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure></li>
<li><p>将可执行权限应用于二进制文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure></li>
<li><p>测试安装</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker-compose --version</span><br><span class="line">docker-compose version 1.25.0, build 0a186604</span><br></pre></td></tr></table></figure>


</li>
</ol>
<p>基于vi在/home/用户名/services/docker-tomcat/下，编写一个docker-compose文件，基于第3版，服务名称自定义。将14Docker Web Container，基于命令行创建容器的命令，转为在文件中描述，包括tomcat基础镜像，挂载目录，映射端口<br>基于文件创建在后台运行的容器；</p>
<blockquote>
<p><code>version</code>：版本注释，不可缺少的字段。<br><code>services</code>：该层级下指明使用镜像开启容器的具体配置，是最主要的配置项。<br><code>flask-web、redis、web</code>：自定义的该service名字。<br><code>build</code>：Dockerfile的路径，使用它来创建一个定制的镜像，或者可使用image指定已有镜像。<br><code>image</code>：指定使用已有镜像。<br><code>ports</code>：开启容器后暴露的端口映射。<br><code>container_name</code>:指定开启容器后的容器名。</p>
</blockquote>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">'3'</span></span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">"80:8080"</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>

<p>停止/停止删除基于文件创建的容器  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker-compose stop</span><br><span class="line">docker-compose down</span><br></pre></td></tr></table></figure>

<p>查看编排内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose ps</span><br></pre></td></tr></table></figure>

<p>查看容器日志，错误时可查看  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker-compose logs</span><br><span class="line">docker inspect iamage-name</span><br></pre></td></tr></table></figure>

<h3 id="最终部署使用"><a href="#最终部署使用" class="headerlink" title="最终部署使用"></a>最终部署使用</h3><ol>
<li>使用<code>docker-compose config</code>检查语法是否错误</li>
<li>使用<code>docker-compose up -d</code>后台启动服务，过程中会自动根据Dockerfile创建镜像，并且按要求启动服务</li>
<li>使用<code>docker-compose logs</code>检查运行状态</li>
<li>检查项目是否正常运行：<code>curl 127.0.0.1:5000</code>，每次访问能收到变化的数据证明项目部署已经成功完成。</li>
</ol>
<p>注意，严格的缩进与空格</p>
<h1 id="docker安装MySQL8"><a href="#docker安装MySQL8" class="headerlink" title="docker安装MySQL8+"></a>docker安装MySQL8+</h1><p>1、<code>docker pull mysql</code>(# 由于当时最新版是mysql8.0,就不用写版本号tag了)</p>
<p>2、<code>docker run -p 3306:3306 --name MYSQL8.0 -e MYSQL_ROOT_PASSWORD=root -d mysql:latest</code></p>
<ul>
<li><p>-p 3306:3306：将容器内的3306端口映射到实体机3306端口</p>
</li>
<li><p>--name MYSQL8.0：给这个容器取一个容器记住的名字</p>
</li>
<li><p>-e MYSQL_ROOT_PASSWORD=123456：docker的MySQL默认的root密码是随机的，这是改一下默认的root用户密码</p>
</li>
<li><p>-d mysql:latest：在后台运行mysql:latest镜像产生的容器</p>
</li>
</ul>
<p>新装了mysql8.0后再用navicat链接就会报2059的错误。</p>
<p>上网查了发现是8.0之后mysql更改了密码的加密规则，只要在命令窗口把加密方法改回去即可。</p>
<p>3、<code>docker exec -it MYSQL8.0 bash</code> <code>mysql -uroot -proot</code></p>
<p>4、改回原来方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alter user &#39;root&#39;@&#39;%&#39; identified by &#39;root&#39; password expire never;</span><br><span class="line">alter user &#39;root&#39;@&#39;%&#39; identified with mysql_native_password by &#39;root&#39;;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 3306:3306 --name MYSQL8.0 -e MYSQL_ROOT_PASSWORD=root -d mysql --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci</span><br><span class="line"><span class="meta">#</span><span class="bash">所有表的默认编码和排序规则以使用UTF-8</span></span><br></pre></td></tr></table></figure>



<h1 id="DOCKERFILE-dockerfile"><a href="#DOCKERFILE-dockerfile" class="headerlink" title="DOCKERFILE dockerfile"></a>DOCKERFILE dockerfile</h1><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> tomcat</span><br><span class="line"><span class="keyword">MAINTAINER</span> TanWentao &lt;<span class="number">1079966197</span>@qq.com&gt;</span><br><span class="line"><span class="keyword">ENV</span> WORK_PATH /usr/local/tomcat/conf</span><br><span class="line"><span class="comment">#定义要替换的server.xml文件名</span></span><br><span class="line"><span class="keyword">ENV</span> SERVER_CONF_FILE_NAME server.xml</span><br><span class="line"><span class="comment">#删除原文件server.xml</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> rm <span class="variable">$WORK_PATH</span>/<span class="variable">$SERVER_CONF_FILE_NAME</span></span></span><br><span class="line"><span class="comment">#复制文件server.xml</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash">  ./<span class="variable">$SERVER_CONF_FILE_NAME</span> <span class="variable">$WORK_PATH</span>/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash">  ./BakaRiceHome-1.0-SNAPSHOT.war /usr/<span class="built_in">local</span>/tomcat/webapps/</span></span><br></pre></td></tr></table></figure>



<h2 id="dockerfile-springboot"><a href="#dockerfile-springboot" class="headerlink" title="dockerfile springboot"></a>dockerfile springboot</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">11</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> TanWentao &lt;<span class="number">1079966197</span>@qq.com&gt;</span><br><span class="line"><span class="comment"># 用于指定持久化目录</span></span><br><span class="line"><span class="comment">#VOLUME /tmp</span></span><br><span class="line"><span class="comment"># 将本地文件添加到容器中</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> birthday.jar app.jar</span></span><br><span class="line"><span class="comment"># 指定于外界交互的端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"><span class="comment"># 配置容器，使其可执行化</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> <span class="built_in">exec</span> java <span class="variable">$JAVA_OPTS</span> -jar /app.jar</span></span><br></pre></td></tr></table></figure>
    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/03/18/%E5%85%B3%E4%BA%8ENeo4j%E9%82%A3%E7%82%B9%E4%BA%8B/" rel="prev" title="关于Neo4j那"点"事">
      <i class="fa fa-chevron-left"></i> 关于Neo4j那"点"事
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/03/18/sql%E7%9A%84%E9%80%BC%E9%80%BC%E5%8F%A8%E5%8F%A8/" rel="next" title="sql的逼逼叨叨（小声）">
      sql的逼逼叨叨（小声） <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Linux-Docker-Examples"><span class="nav-number">1.</span> <span class="nav-text">Linux-Docker Examples</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-11-16-1-Virtual-Machine"><span class="nav-number">1.0.1.</span> <span class="nav-text">2019.11.16 - 1.Virtual Machine</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-11-16-2-CentOS"><span class="nav-number">1.0.2.</span> <span class="nav-text">2019.11.16 - 2.CentOS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-11-16-3-SSH"><span class="nav-number">1.0.3.</span> <span class="nav-text">2019.11.16 - 3.SSH</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-11-16-4-Don’t-Be-Scared-of-the-Terminal"><span class="nav-number">1.0.4.</span> <span class="nav-text">2019.11.16 - 4.Don’t Be Scared of the Terminal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-11-23-5-vi"><span class="nav-number">1.0.5.</span> <span class="nav-text">2019.11.23 - 5.vi</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-11-23-7-Directory-Structure"><span class="nav-number">1.0.6.</span> <span class="nav-text">2019.11.23 - 7.Directory Structure</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-11-30-8-Mount"><span class="nav-number">1.0.7.</span> <span class="nav-text">2019.11.30 - 8.Mount</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-11-26-9-bash-amp-chmod"><span class="nav-number">1.0.8.</span> <span class="nav-text">2019.11.26 - 9.bash &amp; chmod</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-11-26-10-Docker"><span class="nav-number">1.0.9.</span> <span class="nav-text">2019.11.26 - 10.Docker</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-虚拟化技术-amp-docker虚拟化优势"><span class="nav-number">1.0.9.1.</span> <span class="nav-text">1.虚拟化技术&amp;docker虚拟化优势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-What-is-vps-and-Cloud-Servers"><span class="nav-number">1.0.9.2.</span> <span class="nav-text">2.What is vps and Cloud Servers?</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-11-26-11-Docker-Images"><span class="nav-number">1.0.10.</span> <span class="nav-text">2019.11.26 - 11.Docker Images</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-11-26-12-Docker-Container"><span class="nav-number">1.0.11.</span> <span class="nav-text">2019.11.26 - 12.Docker Container</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Docker-run"><span class="nav-number">1.0.11.1.</span> <span class="nav-text">Docker run</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Docker-exec"><span class="nav-number">1.0.11.2.</span> <span class="nav-text">Docker exec</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-11-26-13-FirewallD-amp-Services"><span class="nav-number">1.0.12.</span> <span class="nav-text">2019.11.26 - 13.FirewallD &amp; Services</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-11-26-14-Docker-Web-Container"><span class="nav-number">1.0.13.</span> <span class="nav-text">2019.11.26 - 14.Docker Web Container</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-11-26-15-Dockerfile"><span class="nav-number">1.0.14.</span> <span class="nav-text">2019.11.26 - 15.Dockerfile</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-layer的理解"><span class="nav-number">1.0.14.1.</span> <span class="nav-text">1. layer的理解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-11-26-16-Docker-compose"><span class="nav-number">1.0.15.</span> <span class="nav-text">2019.11.26 - 16.Docker compose</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Orchestration-System？"><span class="nav-number">1.0.15.1.</span> <span class="nav-text">1. Orchestration System？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-为什么需要Docker-Compose？优点？"><span class="nav-number">1.0.15.2.</span> <span class="nav-text">2. 为什么需要Docker Compose？优点？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-k8s-Kubernetes-？k8s与官方docker-compose的适用场景？"><span class="nav-number">1.0.15.3.</span> <span class="nav-text">3. k8s(Kubernetes)？k8s与官方docker compose的适用场景？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-编写docker-compose文件的最大最大特点？"><span class="nav-number">1.0.15.4.</span> <span class="nav-text">4. 编写docker-compose文件的最大最大特点？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-按官网教程安装最新版，添加执行权限"><span class="nav-number">1.0.15.5.</span> <span class="nav-text">5. 按官网教程安装最新版，添加执行权限</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最终部署使用"><span class="nav-number">1.0.16.</span> <span class="nav-text">最终部署使用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#docker安装MySQL8"><span class="nav-number">2.</span> <span class="nav-text">docker安装MySQL8+</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DOCKERFILE-dockerfile"><span class="nav-number">3.</span> <span class="nav-text">DOCKERFILE dockerfile</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#dockerfile-springboot"><span class="nav-number">3.1.</span> <span class="nav-text">dockerfile springboot</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Rice March</p>
  <div class="site-description" itemprop="description">个人杂物箱、 关于编程、日语、生活和阳光 Long may the sunshine!</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Rice March</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.2
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
